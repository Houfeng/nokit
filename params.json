{"name":"Nokit","tagline":"A Web development framework!","body":"##Nokit 简介\r\n最简单易用的 nodejs 开发框架，如果您曾经写过 asp / php 等代码，或者您曾经写过 JavaScript 客户端代码，\r\n那么您会非常易于上手，Nokit 不同于常见的 nodejs 框架，Nokit 提供了多种开发模式，包括 MVC / NSP / RESTful Service ，\r\n开发人员也可以方便的扩展新模式。\r\nNokit 开发交流 QQ 群: 240603160\r\n\r\n##安装和更新\r\nnokit 依赖 nodejs，所以需先安装 nodejs，具体请参考 nodejs 网站\r\n> [https://nodejs.org/](https://nodejs.org/)\r\n\r\n####安装 nokit\r\n```javascript\r\nnpm install -g nokit-runtime\r\n```\r\n\r\n####更新 nokit\r\n```javascript\r\nnpm update -g nokit-runtime\r\n```\r\n\r\n##命令行工具\r\nnokit 应用只需在磁盘建立应用目录，并新建 web.json 配置文件，以及其它相关目录即可， nokit 提供了方便的命令行工具。\r\n\r\n####查看版本\r\n```javascript\r\nnokit 或 nokit ?\r\n```\r\n\r\n####创建应用\r\n```javascript\r\nnokit create <应用名称> [目标目录(默认为当前目录)] [类型(默认为nsp)]\r\n```\r\n以上命令会生成一个最简单的应用所需要的目录结构和配置。\r\n\r\n####运行应用\r\n```javascript\r\nnokit <应用根目录> [端口(也可在web.json中指定或省略)]\r\n```\r\n\r\n##代码引用\r\n除了使用命令行工具，也可以在代码中引用 nokit 的方式来运行 nokit 应用\r\n```javascript\r\nvar nokit = require(\"nokit-runtime\");\r\nvar server = new nokit.Server({\r\n    root : \"应用根目录\",\r\n    port : 8000\r\n});\r\nserver.start();\r\n```\r\n\r\n无论任种方式，启动成功后，即可浏览器访问 \"http://localhost:8000\" (端口请换成具体应用的正确的端口)，\r\n如简单的示例 [http://www.xhou.net:8000](http://www.xhou.net:8000)\r\n\r\n##NSP\r\nNSP 全称为 Nokit Server Pages 也可以理解为 Node Server Pages，是一种类似 asp / php 的 Web 应用开发模式，\r\nNSP 支持 include 引用其它页面，也支持 master 母板页技术。\r\n\r\n一般目录结构\r\n```javascript\r\n根目录\r\n│ web.json\r\n├─layout\r\n│     date.nsp\r\n│     master.nsp\r\n├─model\r\n└─public\r\n    │  index.nsp\r\n    │  index.nsp.js\r\n    └─style\r\n         common.css\r\n```\r\n\r\nNSP 页面 (*.nsp) 基本介绍\r\n```html\r\n<!-- 输出内容 -->\r\n<p> <%= \"输出内容\" %> </p>\r\n<!-- this 指向页面处理器，无处理器页面指向默认处理器对象 -->\r\n<p> <%= this.context.request.formData(\"name\") %> </p>\r\n\r\n<!-- 循环 -->\r\n<ul> \r\n<% $.each(this.list,function(i,item){ %>\r\n    <li><%= item.name %></li>\r\n<% }) %>\r\n</ul>\r\n\r\n<!-- 分支 -->\r\n<% if(this.type=='a'){ %>\r\n<span>a</span>\r\n<% }else{ %>\r\n<span>b</span>\r\n<% } %>\r\n\r\n<!-- 包含 -->\r\n<% $.include(\"../layout/head.nsp\") %>\r\n\r\n<!-- 母板页 -->\r\n<html>\r\n...\r\n<div> <% $.placeHolder(\"content1\") %> </div>\r\n...\r\n<div> <% $.placeHolder(\"content2\") %> </div>\r\n...\r\n</html>\r\n\r\n<!-- 内容页 -->\r\n<% $.master(\"./master.nsp\") %>\r\n\r\n<% $.placeBegin(\"content1\") %>\r\n<span>content1</span>\r\n<% $.placeEnd() %>\r\n\r\n<% $.placeBegin(\"content2\") %>\r\n<span>content2</span>\r\n<% $.placeEnd() %>\r\n```\r\n\r\nNSP 页面处理器 (*.nsp.js) 基本介绍\r\n```javascript\r\n//定义页面处理器类型\r\nvar Index = module.exports = function() {};\r\n\r\n//初始化方法，每次回发都将触发 init 方法\r\nIndex.prototype.init = function(context) {\r\n    var self = this;\r\n    /*\r\n    self.server //当前 server 实例\r\n    self.context //当前请上下文对象\r\n    self.request //同 context.request，请求对象\r\n    self.response //同 context.response 响应对象\r\n    //由于 nokit 为异步处理，调用 render() 方法向浏览器呈现页面.\r\n    //不要在 init 方法调用。\r\n    self.render() \r\n    */\r\n    self.name = 'Nokit NSP';\r\n};\r\n\r\n//默认方法，首次打开页面，会触发 load 方法\r\nIndex.prototype.load = function(context) {\r\n    var self = this;\r\n    self.render();\r\n};\r\n\r\n//事件方法，可以绑定到页面中的 html 控件\r\nIndex.prototype.add = function(context) {\r\n    var self = this;\r\n    var val = parseInt(self.numBox.val());\r\n    self.numBox.val(++val);\r\n    self.numBox.css(\"border\",\"solid 1px red\");\r\n    self.render();\r\n};\r\n```\r\n\r\n页面绑定\r\n```html\r\n<!-- 绑定到处理器方法 -->\r\n<input type=\"button\" onclick=\"nsp.call('add')\" value='add' />\r\n```\r\n\r\n共享元素，通过 \"nsp-id\" 声明为，客户端和服务端的共享元素，便可以在客户端和服务端同时操作指定元素，\r\n并能在回发时保持状态，类似 Asp.NET 的 WebForms，但理念、原理又非常不同，NSP 共享元素非常轻量，更简洁易用。\r\n```html\r\n<!-- 此元素可以在服务端和客户端同时访问 -->\r\n<input type=\"text\" value=\"hello\" nsp-id='test' />\r\n```\r\n```javascript\r\nIndex.prototype.add = function(context) {\r\n    var self = this;\r\n    //服务端提供类 jQuery 的元素操作 API (兼容部分常用 jQUery API)\r\n    self.test.val('你好'); \r\n    self.render();\r\n};\r\n```\r\n\r\n\r\n##MVC\r\nNokit MVC 是一种设计简约、符合 MVC 模式 Web 应用开发模式。\r\n\r\n一般目录结构\r\n\r\n```javascript\r\n根目录\r\n│ web.json\r\n├─controllers\r\n│    home.js\r\n├─models\r\n├─public\r\n│  └─style\r\n│       common.css\r\n└─views\r\n     date.html\r\n     home.html\r\n     master.html\r\n```\r\nviews 目录存放的是视图，视图和 NSP 的页面相似，支持 include 和 master，语法也完全相同，\r\n不同是在 mvc 的视图中 this 指向的是模型，视图具有单一的责职 ，就是呈现模型中的数据。\r\ncontrollers 是控制器目录，单个文件为一个控制器，用来响应接受来自用户的请求，并传递给模型，\r\n然后，完成模型和视图的装配。\r\nmodels 为模型目录，nokit 对模型没有统一的要求和控制，应用的业务逻辑应在模型中完成。\r\n\r\nMVC 的控制器示例\r\n```javascript\r\n//定义控制器类型\r\nvar Home = module.exports = function() {};\r\n\r\n/*\r\n默认 action ，\r\n通常用户直接请求某一 url 会被路由到，指定 controller 的默认 action\r\n*/\r\nHome.prototype.index = function() {\r\n    var self = this;\r\n    \r\n    /*\r\n    self.context 可以访问当前请求上下文对象\r\n    self.context.routeData[\"name\"] 可以获取路由数据\r\n    self.context.queryData['name'] 可以获取 queryString 对应数据\r\n    self.context.formData['name'] 可以获取 post 数据\r\n    self.context.data(\"name\") 可以获取客户端传过来的 queryString 或 formData\r\n    */\r\n    \r\n    //通过 self.render 方法呈现指定的视图，并进行模型绑定\r\n    self.render(\"home.html\", {\r\n        \"name\": \"Nokit MVC\"\r\n    });\r\n};\r\n```\r\n\r\nMVC 的 web.json 配置\r\n```javascript\r\n{\r\n    /*\r\n    配置 handler ，将指定的请求交由 MVC Handler 处理，支持正则表达式，\r\n    如示例，将应用的所有请求都交由 MVC 处理，\r\n    在找不到匹配的路由配置时，会转由 Static Handler 处理\r\n    */\r\n    \"handlers\": {\r\n        \"^/\": \"$./handlers/mvc\"\r\n    },\r\n    \"mvc\": {\r\n        /*\r\n        配置 MVC 相关代码文件的存放目录，指定 controller 和 view 的目录位置，\r\n        model 不用配置。\r\n        */\r\n        \"paths\": {\r\n            \"controller\": \"./controllers\",\r\n            \"view\": \"./views\"\r\n        },\r\n        /*\r\n        每一个路由至少需要指定 pattern(URL匹配模式) 和 target(目标contrller)\r\n        还可以通过配置 action 项指定对应的 action (controller方法)。\r\n        pattern 格式示例 \"/user/{userId}\" 其中 userId 是占位符变量，\r\n        可以在 controller 中通过 context.routeData['userId'] 获取。\r\n        */\r\n        \"routes\": [{\r\n            \"pattern\": \"/home\",\r\n            \"target\": \"./home.js\"\r\n        },{\r\n            \"pattern\": \"/\",\r\n            \"target\": \"./home.js\"\r\n        }]\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n##RESTful\r\nNokit 用来开发 RESTful Server 是非常方便和简单的，通过简洁的 URL 路由配置，抽象出和资源对应的请求处理程序文件即可，\r\n可以在处理程序中，根据需求实现 get / post / put 等 http Method 即可。\r\n\r\n一般目录结构\r\n```javascript\r\n根目录\r\n│ web.json\r\n├─public\r\n│  │  index.nsp\r\n│  └─style\r\n│       common.css\r\n└─restful\r\n      user.js\r\n```\r\n\r\nREST 的资源控制器示例\r\n```javascript\r\n//定义资源控制器类型，通常一个资源类型视为一个控制器\r\nfunction User() {};\r\n\r\n//针对 User 的 post HttpMethod 处理方法\r\nUser.prototype.post = function() {\r\n    var self = this;\r\n        \r\n    /*\r\n    self.context 可以访问当前请求上下文对象\r\n    self.context.routeData[\"name\"] 可以获取路由数据\r\n    self.context.queryData['name'] 可以获取 queryString 对应数据\r\n    self.context.formData['name'] 可以获取 post 数据\r\n    self.context.data(\"name\") 可以获取客户端传过来的 queryString 或 formData\r\n    */\r\n    \r\n    var routeData = self.context.routeData;\r\n    self.out(\"routeData:\" + routeData[\"userId\"]);\r\n};\r\n\r\n//针对 User 的 get HttpMethod 处理方法\r\nUser.prototype.get = function() {\r\n    var self = this;\r\n    self.out(\"routeData:\" + routeData[\"userId\"]);\r\n};\r\n\r\n/*\r\n根据需求实现对应的 httpMethod 处理方法即可\r\n*/\r\n\r\nmodule.exports = User;\r\n```\r\n\r\nREST 的 web.json 配置\r\n```javascript\r\n{\r\n    /*\r\n    配置 handler ，将指定的请求交由 REST Handler 处理，支持正则表达式，\r\n    如示例，/api/... 开头的请求，交由 REST Handler 处理\r\n    */\r\n    \"handlers\": {\r\n        \"^/api/\": \"$./handlers/restful\"\r\n    },\r\n    \"restful\": {\r\n        \"path\": \"./restful\", //指定资源控制器的存放目录\r\n        /*\r\n        每一个路由至少需要指定 pattern(URL匹配模式) 和 target(目标contrller)\r\n        pattern 格式示例 \"/user/{userId}\" 其中 userId 是占位符变量，\r\n        REST 的路由配置没有 action 配置项。\r\n        */\r\n        \"routes\": [{\r\n            \"pattern\": \"/api/user/{userId}\",\r\n            \"target\": \"./user.js\"\r\n        }]\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}